# 字符串和正则表达式

##1. 字符串

本章的字符串链接建议,对IE8及以前性能可能不增反退.

```javascript
str += "one" + "two"
```

字符串链接顺序及原理

1. 在内存中创建一个临时字符串
2. 连接后的"onetwo"被赋值给该临时字符串
3. 临时字符串与str当前的值连接
4. 结果付给str

优化
```javascript
str += "one";
str += "two";

or

str =str + "one" +"two";

//str = "one" + str + "two"; 这样优化无作用.
```

这两种都可以避免临时字符串的创建.

为什么`str = "one" + str + "two";`这样的优化会失效呢?

因为除了IE外,其他浏览器都会给最左边的字符串分配更多的内存空间,这样后面字符串要加进来,就可以减少内存的扩增时间.

如果把`one`放在第一个,`str`一般比它要长的多,所以还是要分配额外的内存空间,时间操作上和新增临时字符串无区别.

IE8实现字符串链接,只是记录现在字符串的引用,当你要用它的时候,才把他们连接起来.,代替之前的记录的字符串引用.

IE7更加糟糕.每连接一对字符串都要把他`复制`到一个新内存中.

###1.1 Firefox的编译期合并.

Firefox在赋值便打算中所有要链接的字符串都属于编译器常量.

```javascript
function folding_demo(){
    var str = "compile" + "time" + "folding";
    str += "this" + "work" + "too";
    str = str +"but" +"not" + "this"
}

//同效
function folding_demo(){
    var str ="compiletimefolding";
    str += "thisworktoo";
    str = str +"but" +"not" + "this"
}
```

在复制语句中含有..变量时...他就歇菜了,,所以很多时候其实这种优化不起什么作用.

`YUI Compressor`代码压缩也会做这样的优化.

###1.2 数组项合并

大部分浏览器的数组项合并比其他字符串连接方法要慢.

IE7除外

```javascript
var str = "I'm a hansome man,ye!",
    newStr ="",
    appends = 5000;
    
    while(appends--){
        newStr+=str;
    }
    
    var sts = [];
    while(appends--){
        strs[strs.length] =str;
    }
    //数组内字符串连接
    newStr = strs.join("");
```
IE7的话,后者性能提升几百倍左右..因为IE7避免了地址了重复分配.所以快,但是其他浏览器是前者更优.


###1.3 String.prototype.concat

`concat`能连接任意字符串/数组/对象`toString()`.

但是效率在各个浏览器都比较慢,建议不要用.

##2 正则表达式

###2.1 正则表达式原理

1. 编译

    创建一个正则表达式对象(使用正则直接量/RegExp构造函数),浏览器会验证表达式,然后转化为原生的代码程序,用于执行匹配.`把正则对象赋值给变量,可以避免重复执行这一步骤`.
2. 设置起始搜索位置
    
    起始搜索未知是字符串的起始字符/正则表达式的lastIndex属性(lastIIndex只作为exec和test方法起始搜索未知,并要求在/g表示时),当匹配失败(步骤4),搜索起始位置改为最后一次匹配的起始位置的下一个字符.
3. 匹配每个正则表达式字元
    
    确定起始搜索位置后,开始逐个检查文本和正则表达式模式,当一个特定的字元匹配失败后,正则表达式会回溯到之前尝试匹配的位置,尝试其他可能的路径

4. 匹配成功/失败
    
    如果在字符串当前未知发现一个完全匹配,则匹配成功,如果所有路径都无法匹配,正则回退到第二步,从下一个起始搜索位置重新开始,当最后一个字符串后面的位置都经历了这个过程,还无匹配,正则表达式宣布彻底匹配失败.

###2.2 理解回溯

正则匹配时,会从左到右测试表达式的组成部分,看能否找到匹配项,